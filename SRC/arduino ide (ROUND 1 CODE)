/* pins ready for right and left ultrasonic, right and left color sensor, gyro sensor
 * max servo parameter: f 138, R:107 L:160
 */

#include <tcs3200.h>
#include "Wire.h"
#include <Servo.h>
#include "I2Cdev.h"
#include "MPU6050_6Axis_MotionApps20.h"



// color sensor parameters and pins
tcs3200 rtcs(42, 40, 44, 46, 50);    // pins for RIGHT color sensor  (S0, S1, S2, S3, output pin)  
tcs3200 ltcs(32, 34, 26, 28, 30);    // pins for LEFT color sensor   (S0, S1, S2, S3, output pin)  

int red, green, blue, white;         // variables for RGB and clear color DATA

int ominred = 90, omingreen = 47, ominblue = 55, ominwhite = 166;  // parameter for minimum RGB values in orange color
int omaxred = 100, omaxgreen = 62, omaxblue = 71, omaxwhite = 200;  // parameter for maximum RGB values in orange color

int bminred = 34, bmingreen = 40, bminblue = 50, bminwhite = 142;  // parameter for minimum RGB values in blue color
int bmaxred = 55, bmaxgreen = 83, bmaxblue = 100, bmaxwhite = 166;  // parameter for maximum RGB values in blue color

// ultrasonic sensor parameters and pins
#define fecho 9                      // input echo pin for FORWARD ultrasonic
#define ftrig 8                      // output trig pin for FORWARD ultrasonic

#define recho 6                     // input echo pin for RIGHT ultrasonic
#define rtrig 7                     // output trig pin for RIGHT ultrasonic

#define lecho 11                      // input echo pin for LEFT ultrasonic
#define ltrig 10                      // output trig pin for LEFT ultrasonic

int fdistance,rdistance,ldistance;
int intfdistance,intrdistance,intldistance;
bool intdistance=true;
long duration;

// gyro sensor parameters and pins
#if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
    #include "Wire.h"
#endif

MPU6050 mpu;

#define OUTPUT_READABLE_YAWPITCHROLL





#define INTERRUPT_PIN 18  // use pin 18 on Arduino Uno & most boards
#define LED_PIN 13 // (Arduino is 13, Teensy is 11, Teensy++ is 6)
bool blinkState = false;

// MPU control/status vars
bool dmpReady = false;  // set true if DMP init was successful
uint8_t mpuIntStatus;   // holds actual interrupt status byte from MPU
uint8_t devStatus;      // return status after each device operation (0 = success, !0 = error)
uint16_t packetSize;    // expected DMP packet size (default is 42 bytes)
uint16_t fifoCount;     // count of all bytes currently in FIFO
uint8_t fifoBuffer[64]; // FIFO storage buffer

// orientation/motion vars
Quaternion q;           // [w, x, y, z]         quaternion container
VectorInt16 aa;         // [x, y, z]            accel sensor measurements
VectorInt16 aaReal;     // [x, y, z]            gravity-free accel sensor measurements
VectorInt16 aaWorld;    // [x, y, z]            world-frame accel sensor measurements
VectorFloat gravity;    // [x, y, z]            gravity vector
float euler[3];         // [psi, theta, phi]    Euler angle container
float ypr[3];           // [yaw, pitch, roll]   yaw/pitch/roll container and gravity vector

// packet structure for InvenSense teapot demo
uint8_t teapotPacket[14] = { '$', 0x02, 0,0, 0,0, 0,0, 0,0, 0x00, 0x00, '\r', '\n' };





volatile bool mpuInterrupt = false;     // indicates whether MPU interrupt pin has gone high
void dmpDataReady() {
    mpuInterrupt = true;
}

float angle=ypr[0];                          // variable for angle DATA - Z Axis-

// DC motor parameters and pins
byte dcmotfpin=5;                     // output pin for FORWARD DC driving motor 
byte dcmotbpin=4;                     // output pin for BACKWARD DC driving motor 
int speedo=200;                       // speed for driving dc motor

// stearing motor parameters and pins
//byte stearRmotpin=4;                  
//byte stearLmotpin =5;               
Servo servo;
int pos = 90 ;                       // servo motor intial angle position in forward position
byte servopin = 2;                    // output pwm pin for servo stearing motor



// start button parameters and pins
byte startpin=37;                     // input pin for start push button
byte startsignal;                     // DATA from button - HIGH or LOW-

bool cw=false,ccw=false, intcolor=true;

int cornerlinecount=1;                // count corner line for achivie 3 laps   if counter= 12 then 3 laps              
bool center=false;
bool enLcolor = true, enRcolor = true ;

void setup() 
{
  Serial.begin(115200);
  Wire.begin();
  mpusetup();
  delay(1000);
  pinMode(24,OUTPUT);                      // left color sensor enable
  pinMode(48,OUTPUT);                       // right color sensor enable
  digitalWrite(48,LOW);
  digitalWrite(24,LOW);
  pinMode(ftrig, OUTPUT); 
  pinMode(fecho, INPUT);
  pinMode(rtrig, OUTPUT); 
  pinMode(recho, INPUT);
  pinMode(ltrig, OUTPUT); 
  pinMode(lecho, INPUT);
  pinMode(startpin, INPUT);
  pinMode(dcmotfpin, OUTPUT);
  pinMode(dcmotbpin, OUTPUT);
  digitalWrite(dcmotfpin,LOW);
  digitalWrite(dcmotbpin,LOW);
  servo.attach(servopin);
  servo.write(pos);
  intdistance = true;
  readdistance(ftrig, fecho, 'F');
  delay(50);
  readdistance(rtrig, recho, 'R');
  delay(50);
  readdistance(ltrig, lecho, 'L');
  Serial.print("intfdis= ");
  Serial.println(intfdistance);
  Serial.print("intrdis= ");
  Serial.println(intrdistance);
  Serial.print("intldis= ");
  Serial.println(intldistance);
  while(true)
  {
    startsignal=digitalRead(startpin);
    if(startsignal == HIGH)
    {
      break;
    }
  }
   
  
}

void loop() 
{
  // fnS: readgyro(), readRcolor(), readLcolor(), readdistance(trigPin, echoPin, 'F' || 'R' || 'L')
  // fnS: forward(int speedo), backward(int speedo), left(), right()
  forward(200);
  readdistance(ftrig, fecho, 'F');
  if(fdistance <33 )
  {
    forward(180);
    readRcolor();
    readLcolor();
    if(cw == true )
    {
      enLcolor = false;
      readdistance(rtrig, recho, 'R');
      if( rdistance > 45)
      {
        right();
        readgyro();
        if(angle >90 )
        {
          straight();
          forward(200);
          readdistance(ftrig, fecho, 'F');
          cwlap();
          for ( int i =1 ; i>11 ; i++)
          {
            cwlap();
            if(cornerlinecount == 12)
            {
              cwlap();
              forward(180);
              delay(4000);
              stopdriving();
            }
          }
        }
      }
    }
    if(ccw ==true )
    { enRcolor = false;
      readdistance(ltrig, lecho, 'L');
      if( ldistance > 45)
      {
        left();
        readgyro();
        if(angle <-90 )
        {
          straight();
          forward(200);
          readdistance(ftrig, fecho, 'F');
          ccwlap();
          for ( int i =1 ; i>11 ; i++)
          {
            ccwlap();
            if(cornerlinecount == 12)
            {
              ccwlap();
              forward(180);
              delay(4000);
              stopdriving();
            }
          }
        }
      }
    }
    
    
  }

}
void ccwlap()
{
   if(fdistance <33 )
  {
    forward(180);
    readRcolor();
    readLcolor();
    if(ccw == true )
    {
      enRcolor = false;
      readdistance(ltrig, lecho, 'L');
      if( ldistance > 45)
      {
       left();
        readgyro();
        if(angle <-90 )
        {
          straight();
          forward(200);
        }
      }
    }
  }
}
void cwlap()
{
  if(fdistance <33 )
  {
    forward(180);
    readRcolor();
    readLcolor();
    if(cw == true )
    {
      enLcolor = false;
      readdistance(rtrig, recho, 'R');
      if( rdistance > 45)
      {
        right();
        readgyro();
        if(angle >90 )
        {
          straight();
          forward(200);
        }
      }
    }
  }
}

void w()
{
  while(true)
  {
    
  }
}

void lcenter()
{
  backward(200);
  delay(2000);
  stopdriving();
  left();
  delay(50);
  forward(175);
  delay(1500);
  stopdriving();
  right();
  delay(50);
  forward(175);
  delay(1500);
  stopdriving();
  straight();
  center=true;
}

void rcenter()
{
  backward(200);
  delay(2000);
  stopdriving();
  right();
  delay(50);
  forward(175);
  delay(1500);
  stopdriving();
  left();
  delay(50);
  forward(175);
  delay(1500);
  stopdriving();
  straight();
  center=true;
}

void straight()
{
  pos= 90;
  servo.write(pos);
}

void left()
{
  pos=165;
  servo.write(pos);
}

void right()
{
  pos=40;
  servo.write(pos);
}

void stopdriving()
{
  digitalWrite(dcmotfpin,LOW);
  digitalWrite(dcmotbpin,LOW);
}

void backward(int speedo)
{
  analogWrite(dcmotbpin,speedo);
  digitalWrite(dcmotfpin,LOW);
}

void forward(int speedo)
{
  //digitalWrite(dcmotfpin,HIGH); // moving FORWARD
  analogWrite(dcmotfpin,speedo);
  digitalWrite(dcmotbpin,LOW);
  //delay(500);
  //digitalWrite(dcmotfpin,LOW);
  //digitalWrite(dcmotbpin,LOW);
}


void readgyro()
{
  // if programming failed, don't try to do anything
    if (!dmpReady) return;
    // read a packet from FIFO
    if (mpu.dmpGetCurrentFIFOPacket(fifoBuffer)) { // Get the Latest packet 
        #ifdef OUTPUT_READABLE_QUATERNION
            // display quaternion values in easy matrix form: w x y z
            mpu.dmpGetQuaternion(&q, fifoBuffer);
            Serial.print("quat\t");
            Serial.print(q.w);
            Serial.print("\t");
            Serial.print(q.x);
            Serial.print("\t");
            Serial.print(q.y);
            Serial.print("\t");
            Serial.println(q.z);
        #endif

        #ifdef OUTPUT_READABLE_EULER
            // display Euler angles in degrees
            mpu.dmpGetQuaternion(&q, fifoBuffer);
            mpu.dmpGetEuler(euler, &q);
            Serial.print("euler\t");
            Serial.print(euler[0] * 180/M_PI);
            Serial.print("\t");
            Serial.print(euler[1] * 180/M_PI);
            Serial.print("\t");
            Serial.println(euler[2] * 180/M_PI);
        #endif

        #ifdef OUTPUT_READABLE_YAWPITCHROLL
            // display Euler angles in degrees
            mpu.dmpGetQuaternion(&q, fifoBuffer);
            mpu.dmpGetGravity(&gravity, &q);
            mpu.dmpGetYawPitchRoll(ypr, &q, &gravity);
            //Serial.print("ypr\t");
            //Serial.println(ypr[0] * 180/M_PI);
            angle=ypr[0];
            /*Serial.print("\t");
            Serial.print(ypr[1] * 180/M_PI);
            Serial.print("\t");
            Serial.println(ypr[2] * 180/M_PI);*/
        #endif

        #ifdef OUTPUT_READABLE_REALACCEL
            // display real acceleration, adjusted to remove gravity
            mpu.dmpGetQuaternion(&q, fifoBuffer);
            mpu.dmpGetAccel(&aa, fifoBuffer);
            mpu.dmpGetGravity(&gravity, &q);
            mpu.dmpGetLinearAccel(&aaReal, &aa, &gravity);
            Serial.print("areal\t");
            Serial.print(aaReal.x);
            Serial.print("\t");
            Serial.print(aaReal.y);
            Serial.print("\t");
            Serial.println(aaReal.z);
        #endif

        #ifdef OUTPUT_READABLE_WORLDACCEL
            // display initial world-frame acceleration, adjusted to remove gravity
            // and rotated based on known orientation from quaternion
            mpu.dmpGetQuaternion(&q, fifoBuffer);
            mpu.dmpGetAccel(&aa, fifoBuffer);
            mpu.dmpGetGravity(&gravity, &q);
            mpu.dmpGetLinearAccel(&aaReal, &aa, &gravity);
            mpu.dmpGetLinearAccelInWorld(&aaWorld, &aaReal, &q);
            Serial.print("aworld\t");
            Serial.print(aaWorld.x);
            Serial.print("\t");
            Serial.print(aaWorld.y);
            Serial.print("\t");
            Serial.println(aaWorld.z);
        #endif
    
        #ifdef OUTPUT_TEAPOT
            // display quaternion values in InvenSense Teapot demo format:
            teapotPacket[2] = fifoBuffer[0];
            teapotPacket[3] = fifoBuffer[1];
            teapotPacket[4] = fifoBuffer[4];
            teapotPacket[5] = fifoBuffer[5];
            teapotPacket[6] = fifoBuffer[8];
            teapotPacket[7] = fifoBuffer[9];
            teapotPacket[8] = fifoBuffer[12];
            teapotPacket[9] = fifoBuffer[13];
            Serial.write(teapotPacket, 14);
            teapotPacket[11]++; // packetCount, loops at 0xFF on purpose
        #endif

        // blink LED to indicate activity
        blinkState = !blinkState;
        digitalWrite(LED_PIN, blinkState);
    }
}

void readRcolor()
{
  red = rtcs.colorRead('r');
  /*Serial.print("R= ");
  Serial.print(red);
  Serial.print("        ");
  //delay(5);*/
  green = rtcs.colorRead('g');
  /*Serial.print("G= ");
  Serial.print(green);
  Serial.print("        ");
  //delay(5);*/
  blue = rtcs.colorRead('b');
  /*Serial.print("B= ");
  Serial.print(blue);
  Serial.print("        ");
  //delay(5);*/
  white = rtcs.colorRead('c');
  /*Serial.print("c= ");
  Serial.println(white);
  //delay(5);*/
  if(ominred <= red && red <= omaxred && omingreen <= green && green <= omaxgreen && ominblue <= blue && blue <= omaxblue)
  {
    Serial.println("orange line detected. clock wise direction");
    cw=true;
    ccw=false;
    cornerlinecount++;
    intcolor=false;
  }
  //else
  //Serial.println("go forward");

}

void readLcolor()
{
  red = ltcs.colorRead('r');
  /*Serial.print("R= ");
  Serial.print(red);
  Serial.print("        ");
  //delay(5);*/
  green = ltcs.colorRead('g');
  /*Serial.print("G= ");
  Serial.print(green);
  Serial.print("        ");
  //delay(5);*/
  blue = ltcs.colorRead('b');
  /*Serial.print("B= ");
  Serial.print(blue);
  Serial.print("        ");
  //delay(5);*/
  white = ltcs.colorRead('c');
  /*Serial.print("c= ");
  Serial.println(white);
  //delay(5);*/
  if(bminred <= red && red <= bmaxred && bmingreen <= green && green <= bmaxgreen && bminblue <= blue && blue <= bmaxblue)
  {
    Serial.println("blue detected. counter clock wise direction");
    ccw=true;
    cw=false;
    cornerlinecount++;
    intcolor=false;
  }
  //else
  //Serial.println("go forward");
}


void readdistance(int trigPin, int echoPin, char u)
{
  
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  duration = pulseIn(echoPin, HIGH);
  if(u=='F')
  {
    fdistance = duration * 0.034 / 2;
    if(intdistance == true)
    {
      intfdistance = duration * 0.034 / 2;
      intdistance = false;
    }
  }
  if(u=='R')
  {
    rdistance = duration * 0.034 / 2 ;
    if(intdistance == true)
    {
      intrdistance = duration * 0.034 / 2;
      intdistance = false;
    }
  }
  if(u=='L')
  {
    ldistance = duration * 0.034 / 2;
    if( intdistance == true)
    {
      intldistance = duration * 0.034 / 2;
      intdistance = false;
    }
  }

}

void readul()
{
  readdistance(ftrig, fecho, 'F');
  delay(10);
  readdistance(rtrig, recho, 'R');
  delay(10);
  readdistance(ltrig, lecho, 'L');
}

void mpusetup()
{
  #if I2CDEV_IMPLEMENTATION == I2CDEV_ARDUINO_WIRE
        Wire.begin();
        Wire.setClock(400000); // 400kHz I2C clock. Comment this line if having compilation difficulties
    #elif I2CDEV_IMPLEMENTATION == I2CDEV_BUILTIN_FASTWIRE
        Fastwire::setup(400, true);
    #endif


    Serial.begin(115200);
    while (!Serial); 

    
    Serial.println(F("Initializing I2C devices..."));
    mpu.initialize();
    pinMode(INTERRUPT_PIN, INPUT);

    // verify connection
    Serial.println(F("Testing device connections..."));
    Serial.println(mpu.testConnection() ? F("MPU6050 connection successful") : F("MPU6050 connection failed"));

    // wait for ready
    /*Serial.println(F("\nSend any character to begin DMP programming and demo: "));
    while (Serial.available() && Serial.read()); // empty buffer
    while (!Serial.available());                 // wait for data
    while (Serial.available() && Serial.read()); // empty buffer again*/

    // load and configure the DMP
    Serial.println(F("Initializing DMP..."));
    devStatus = mpu.dmpInitialize();

    // supply your own gyro offsets here, scaled for min sensitivity
    mpu.setXGyroOffset(220);
    mpu.setYGyroOffset(76);
    mpu.setZGyroOffset(-85);
    mpu.setZAccelOffset(1788); // 1688 factory default for my test chip

    // make sure it worked (returns 0 if so)
    if (devStatus == 0) {
        // Calibration Time: generate offsets and calibrate our MPU6050
        mpu.CalibrateAccel(6);
        mpu.CalibrateGyro(6);
        mpu.PrintActiveOffsets();
        // turn on the DMP, now that it's ready
        Serial.println(F("Enabling DMP..."));
        mpu.setDMPEnabled(true);

        // enable Arduino interrupt detection
        Serial.print(F("Enabling interrupt detection (Arduino external interrupt "));
        Serial.print(digitalPinToInterrupt(INTERRUPT_PIN));
        Serial.println(F(")..."));
        attachInterrupt(digitalPinToInterrupt(INTERRUPT_PIN), dmpDataReady, RISING);
        mpuIntStatus = mpu.getIntStatus();

        // set our DMP Ready flag so the main loop() function knows it's okay to use it
        Serial.println(F("DMP ready! Waiting for first interrupt..."));
        dmpReady = true;

        // get expected DMP packet size for later comparison
        packetSize = mpu.dmpGetFIFOPacketSize();
    } else {

        Serial.print(F("DMP Initialization failed (code "));
        Serial.print(devStatus);
        Serial.println(F(")"));
    }

    // configure LED for output
    pinMode(LED_PIN, OUTPUT);
}

/*
 *   // fnS: readgyro(), readRcolor(), readLcolor(), readdistance(trigPin, echoPin, 'F' || 'R' || 'L')
  // fnS: forward(int speedo), backward(int speedo), left(), right()
  int c_angle = 0;
  int roun = 1;
  //readLcolor();
  /*if(abs(intrdistance - intldistance) >  15 && center == false)
  //if(intldistance < intrdistance && center == false)
  {
    rcenter();  // go to right();
  }
  if(abs(intldistance - intrdistance) >  15 && center == false)
  //if(intldistance > intrdistance && center == false)
  {
    lcenter();  // go to left
  }
  delay(50);*/
  /*forward(200);
  readdistance(ftrig, fecho, 'F');
  if(fdistance <=30)
  {
    stopdriving();
  }
  if(fdistance <= 105 && fdistance >33)
  {
    forward(180);
    while(true)
    {
      if(enRcolor == true)
      {
        readRcolor();
        enLcolor=false;
      }
      if(enLcolor == true)
      {
        readLcolor();
        enRcolor=false;
      }
      if( cw == true)
      {
        right();
        while(true)
        {
          readgyro();
          readul();
          if(fdistance < 12)
          {
            stopdriving();
            Serial.println("fdistance");
            w();
          }

        if(angle >= 0 && angle < 180){
           c_angle =(( angle  / 95) +1) *90;
          
           Serial.print(angle );
           Serial.print(" ------ ");
           Serial.println( c_angle);
            if(angle > c_angle + 2 && angle < c_angle + 8)  // first  orange
              {
                straight();
                forward(200);
                 //stopdriving();
                //Yaw= Yaw *0;                  // to be tested
               angle=angle+3;
               roun++;
               Serial.print(" Go Stright ");
               Serial.println(roun);
                cw = false;
                break;
              }
        } else {
           c_angle =(( angle  / 95) -1) *90;
          
           Serial.print(angle );
           Serial.print(" ------ ");
           Serial.println( c_angle);
           //stopdriving();
           //w();
            if(angle >= c_angle + 4 && angle <= c_angle + 7)  // first  orange
              {
                straight();
                forward(200);
                if(roun ==5){
                 straight();
                  forward(200);
                 roun = 1;
                 break;
                 }
                 //stopdriving();
                //Yaw= Yaw *0;                  // to be tested
               angle=angle+3;
               roun++;
               Serial.print(" Go Stright ");
               Serial.println(roun);
                cw = false;
                break;
              }
        }
          
        
           
        /*  if(angle > (c_angle *90 - 5) && angle < (c_angle * 90 + 5))  // first  orange
          {
            straight();
            forward(200);
            Serial.println(angle);
            //Yaw= Yaw *0;                  // to be tested
           // angle=angle-90;
            Serial.print("corr angle: ");
            Serial.println(angle);
           
            cw = false;
            break;
          }*/
          //break;
          /*if(angle > 170 && angle < 170)  // second orange
          {
            straight();
            forward(200);
            Serial.println(angle);
            break;
          }
          //break;
          /*if(angle > 170 && angle < 230)  // third orange
          {
            straight();
            forward(200);
            Serial.println(angle);
            break;
          }*/
          
       /* }
        //break;
      }
      if( ccw == true)
      {
        left();
        while(true)
        {
          readgyro();
          if(angle > -83 && angle < 0)
          {
            straight();
            forward(200);
            Serial.println(angle);
            //Yaw= Yaw *0;                  // to be tested
            //angle=0;
            break;
          }
        }
        break;
      }
    }
  }
  
  
  
  
  /*right();
  delay(800);
  forward(190);
  while(true)
  {
    readgyro();
    if(angle > 83)
    {
      Serial.println("stop");
      stopdriving();
      while(true)
      {
        Serial.println(angle);
        delay(400);
      }
    }
  }*/
  /*readul();
  Serial.println(rdistance);
  delay(400);
  */
  /*left();
  delay(1500);
  straight();
  delay(1500);
  right();
  delay(1500);
  straight();*/
  /*left();
  readgyro();
  Serial.println(angle);
  delay(1000);
  forward(200);
  while(true)
   {
    readgyro();
    if(angle > 87)
    {
      stopdriving();
      Serial.println(angle);
      Serial.println("more than 87 deg");
    }
    readdistance(rtrig, recho, 'R');
    Serial.print(rdistance);
    if(rdistance < 20)
    {
      stopdriving();
      delay(50);
      right();
      backward(200);
      delay(2000);
      stopdriving();
      delay(50);
      left();
      forward(200);
    }
    //break;

   }
  while(true)
  {
    
  }*/
  /*forward(250);
  delay(1000);
  right();
  forward(250);
  delay(800);
  straight();
  forward(250);
  delay(700);
  forward(230);
  delay(1500);
  straight();
  //stopdriving();
  delay(1500);
  forward(250);
  left();
  delay(1500);
  straight();
  stopdriving();
  while(true)
  {
    
  }*/
  // #########################################################
  /*forward(220);
  readdistance(ftrig, fecho, 'F');
  if(fdistance <=30)
  {
    stopdriving();
  }
  if(fdistance <= 105 && fdistance >33)
  {
    //left();
    while(true)
    {
      forward(175);
      Serial.println(fdistance);
      if ( intcolor == true)
      {
        readRcolor();
        readLcolor();
      }
      if(cw == true)         // turn right
      {
        Serial.println("CW");
        cornerlinecount=cornerlinecount+1;
        if(cornerlinecount == 4)
        {
          stopdriving();
        }
        right();
        //delay(1000);
        //stopdriving();
        while(true)
        {
          readul();
          readgyro();
          Serial.println(fdistance);
          Serial.println(ldistance);
          Serial.println("     ");
          if(fdistance < 20 || angle < -65)
          {
            straight();
            //stopdriving();
            Serial.println(angle);
            break;
          }
        }
        //break;
      }
      else if( ccw == true)    // turn left
      {
        Serial.println("CCW");
        left();
        delay(1000);
        stopdriving();
        //break;
        while(true)
        {
          
        }*/
        /*while(true)
        {
          forward(250);
          left();
          delay(350);
          straight();
          delay(350);
          left();
          readdistance(ftrig, fecho, 'F');
          readdistance(ltrig, lecho, 'L');
          readgyro();
          if( angle >= 90)
          {
            stopdriving();
          }
          if( fdistance <= 45)
          {
            stopdriving();
            straight();
            delay(50);
            backward(250);
            delay(1200);
            right();
            delay(1200);
            stopdriving();
            forward(250);
            delay(800);
            left();
            if( angle >= 90)
            {
              stopdriving();
            }
          }
          Serial.println(angle);
          Serial.println(fdistance);
          Serial.println(ldistance);
          Serial.println("    ");
          delay(3000);
          stopdriving();
            while(true)
            {
              
            }
            
        }
        break;
        
      }
    }*/
    
    
  

 

  /*if( ccw == true )
  {
    angle=0;
    left();
    
  }

  if( cw == true )
  {
    right();
    digitalWrite(2,LOW);
    while(true)
    {
        
    }
  }*/

  // ######################################################

  
 
 /* readRcolor();
  delay(650);
  digitalWrite(2,LOW);
  digitalWrite(3,LOW);
  while (true)
  {
    
  }*/
  /*readdistance(ftrig, fecho, 'F');
  Serial.println(fdistance);
  readdistance(rtrig, recho, 'R');
  Serial.println(rdistance);
  readdistance(ltrig, lecho, 'L');
  Serial.println(ldistance);
  Serial.println("    ");*/
  //readLcolor();
  //readRcolor();
  /*while( fdistance < 100 )
  {
    forward(150);
    readRcolor();
    readLcolor();
    if( cw == true || ccw == true)
    {
      break;
    }
    //else
    //search for blue or orange line
  }*/

  
  //delay(400);
  

  /*while(true)
  {
    
  }*/
